<!DOCTYPE html>
<html lang="en-us">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
	<title>Unity WebGL Player | vm</title>
	<style>
	</style>
    <script type="text/javascript" src="js/webgazer.js"></script>
    <script src="Build/UnityLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>
  </style>

    <script>
    var gameInstance = UnityLoader.instantiate("gameContainer", "Build/Build.json",{Module: {TOTAL_STACK:6*1024*1024}});
	</script>
  </head>

  <body>
    <div id="gameContainer" style="width: 100%; height:100%;"></div>
    <!-- <video id="input_video"></video>
    <canvas class="output_canvas" width="1280px" height="720px"></canvas>-->
	<script>
		//const videoElement = document.getElementById('input_video');
    //const canvasElement = document.getElementsByClassName('output_canvas')[0];
    //const canvasCtx = canvasElement.getContext('2d');

    //let lands;
    webgazer.setGazeListener(function(data, elapsedTime) {
			if (data == null) {
				return;
			}
			var xprediction = data.x;
			var yprediction = data.y;
			document.cookie = "x="+Math.floor(xprediction);
			document.cookie = "y="+Math.floor(yprediction);
			document.cookie = "z="+0;//Math.floor((lands[76].y + lands[306].y - lands[0].y - lands[0].y) * 100);
			var cookies = document.cookie;
			console.log("cookies = "+cookies);
		}).begin();

    function FaceDetected(){
      var ready = this.webgazer.getTracker().predictionReady
      gameInstance.SendMessage("GameObject", "CameraReady", ready.toString());
    }
    function HideVideo(){
      webgazer.showVideo(false);
      this.webgazer.showFaceOverlay(false);
      this.webgazer.showFaceFeedbackBox(false);
    }
    function ShowVideo(){
      webgazer.showVideo(true);
      this.webgazer.showFaceOverlay(true);
      this.webgazer.showFaceFeedbackBox(true);
    }
    function Pause(){
      webgazer.pause();
    }
    function Resume(){
      webgazer.resume();
    }
    function ClearData(){
      webgazer.clearData();
    }
    function OffCalibration(){
      webgazer.removeMouseEventListeners();
    }
    function OnCalibration(){
      webgazer.addMouseEventListeners();
    }
    function HidePoint(){
      webgazer.params.showGazeDot = false;
      webgazer.showPredictionPoints(false);
    }
    function ShowPoint(){
      webgazer.showPredictionPoints(true);
    }
	
    
    

    /*function onResults(results) {
      if (results.multiFaceLandmarks) {
        for (const landmarks of results.multiFaceLandmarks) {
          lands = landmarks;
        }
      }
      canvasCtx.save();
      canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
      canvasCtx.drawImage(
      results.image, 0, 0, canvasElement.width, canvasElement.height);
      if (results.multiFaceLandmarks) {
        for (const landmarks of results.multiFaceLandmarks) {
          drawConnectors(canvasCtx, landmarks, FACEMESH_TESSELATION,
                        {color: '#C0C0C070', lineWidth: 1});
          drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYE, {color: '#FF3030'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_EYEBROW, {color: '#FF3030'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_RIGHT_IRIS, {color: '#FF3030'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYE, {color: '#30FF30'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_EYEBROW, {color: '#30FF30'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_LEFT_IRIS, {color: '#30FF30'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_FACE_OVAL, {color: '#E0E0E0'});
          drawConnectors(canvasCtx, landmarks, FACEMESH_LIPS, {color: '#E0E0E0'});
          drawConnectors(canvasCtx, landmarks, [[76,17],[17,306],[306,0],[0,76]],{color:'#ff0000'});
        }
      }
      canvasCtx.restore();
    }
    
    const faceMesh = new FaceMesh({locateFile: (file) => {
      return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
    }});
    faceMesh.setOptions({
      maxNumFaces: 1,
      refineLandmarks: true,
      minDetectionConfidence: 0.5,
      minTrackingConfidence: 0.5
    });
    faceMesh.onResults(onResults);
    
    const camera = new Camera(videoElement, {
      onFrame: async () => {
        await faceMesh.send({image: videoElement});
      },
      width: 1280,
      height: 720
    });
    camera.start();*/
  </script>
  <!--<script>
    var gameInstance = UnityLoader.instantiate("gameContainer", "Build/Build.json");

    function Start() {
        SpeechRecognition = webkitSpeechRecognition || SpeechRecognition;
        const recognition = new SpeechRecognition();

        recognition.continuous = true;

        recognition.onnomatch = function () {
            window.alert("セットアップに失敗しました。ページの再読み込みをしてください。")
        };

        recognition.onerror = function () {
            console.log("エラーが発生しました。再接続をします。")
            Start();
        };

        recognition.onsoundend = function () {
            console.log("音声入力が停止しました。再接続します。")
            Start();
        }

        recognition.onresult = (event) => {
            gameInstance.SendMessage('SceneManager', 'OnMessage', event.results[event.results.length - 1][0].transcript);
        };

        recognition.start();
    }

    Start();
</script>-->
  </body>
</html>